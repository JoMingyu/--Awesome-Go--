package main

func main() {
	// 배열은 고정된 크기 안에 동일한 타입의 데이터를 연속적으로 저장하지만 크기를 동적으로 증가시키거나 부분 배열을 발췌하는 등의 기능을 가지고 있지 않음

	// Slice는 내부적으로 동적 배열의 개념으로 구현되었기 때문에 필요에 따라 크기를 늘리거나 줄일 수 있음
	// append와 같이 빠르게 효과적으로 크기를 조절할 수 있는 내장 함수를 제공하기 때문에 크기 측면에서도 유연하고
	// 메모리가 연속적인 블록으로 할당되기 때문에 인덱싱, iteration과 GC에서의 장점도 제공하기 때문에 대부분 배열보단 슬라이스를 사용한다

	var x []int
	// 배열과 슬라이스는 문법적으로 굉장히 비슷한데, 선언식에 길이 정의가 없다는 특징을 알고 있으면 구별하기 쉽다
	// 슬라이스는 배열과 다르게 길이가 불분명하기 때문에 zero value를 할당할 수 없으므로, 위처럼 값이 없는 경우 슬라이스의 zero value인 'nil'이 할당된다
	println(x == nil)
	// true

	x2 := []int{1, 2, 3}
	_ = x2
	// 리터럴을 사용한 초기값과 함께 슬라이스 생성

	x3 := []int{}
	// 위의 경우 경우 값이 할당되었기 때문에 nil이 아니며 단지 길이가 0인 slice
	// nil slice와 길이가 0인 empty slice를 구분할 수 있어야 함
	println(x3 == nil)
	// false

	x4 := make([]int, 5)
	_ = x4
	// 특정 길이에 zero value가 채워진 슬라이스를 생성하려는 경우, make()라는 빌트인 함수를 사용한다
	// 위의 경우 길이가 5인 슬라이스가 생성되며, 모두 int의 zero value인 0으로 채워진다

	x5 := make([]int, 5, 10)
	// make에 전달할 수 있는 세 번째 매개변수는 슬라이스의 최대 길이를 나타낸다

	println(len(x5), cap(x5))
	// 슬라이스의 길이와 용량

	x5 = append(x5, 10)
	// 슬라이스에 값 append
	// 해당 슬라이스의 cap까지만큼만 append 가능하다

	for i, v := range x5 {
		println(i, v)
	}

	println(x5[:3])
	println(x5[2:4])
	// Python의 슬라이싱 개념과 동일하게 슬라이싱 가능
}
